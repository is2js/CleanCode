import copy


def solution():
    # 재미있고 이득이 되는 객체 복제하기
    # 객체의 얕은 복사본을 만들면 자식 객체가 복사되지 않는다. 따라서 사본은 원본과 완전히 독립적이지 않다.
    # #### 깊은 복사는 객체의 자식 객체를 재귀적으로 복사한다.
    # 이렇게 얻은 복사본은 원본과 완전히 독립적이지만, 그만큼 시간이 더 걸린다.
    # copy 모듈을 사용하여 임의의 객체를 복사할 수 있다.

    # 1. 얕은복사
    xs = [[1,2,3], [4,5,6], [7,8,9]]
    # (1) 생성자 복사 = 얕은 복사
    ys_1 = list(xs)
    print(f"얕은 복사 원본 > {ys_1}")
    # (1-1) 얕은복사는 원본컬렉션 자체 CRUD수정시 안 변한다.
    xs.append([10, 11, 12])
    print(f"원본 수정 > {xs}")
    print(f"얕은 복사 > {ys_1}")
    # (1-2) 얕은복사는 내부요소 조작시, 값이 아니라면 같이 변한다. 요소 복사를 안한다.
    xs[1][0] = 'X' # 원본의 2번째 요소의 값을 변화
    print(f"원본 수정 > {xs}")
    print(f"얕은 복사 > {ys_1}") # 얕은복사본의 요소도 같이 변화

    # (2) slicing 복사 = 얕은 복사
    xs = [[1,2,3], [4,5,6], [7,8,9]]
    ys_2 = xs[:]
    print(f"얕은 복사2 원본 > {ys_2}")
    # (1-1) 얕은복사는 원본컬렉션 자체 CRUD수정시 안 변한다.
    xs.append([10, 11, 12])
    print(f"원본 수정 > {xs}")
    print(f"얕은 복사2 > {ys_2}")
    # (1-2) 얕은복사는 내부요소 조작시, 값이 아니라면 같이 변한다. 요소 복사를 안한다.
    xs[1][0] = 'X' # 원본의 2번째 요소의 값을 변화
    print(f"원본 수정 > {xs}")
    print(f"얕은 복사2 > {ys_2}") # 얕은복사본의 요소도 같이 변화

    #### 요소가 값일 경우, 얕은복사본만으로 충분하다. 요소가 객체 이상일 경우 문제 발생

    # (3) 깊은 복사는 copy.deepcopy를 이용해야한다.
    xs = [[1,2,3], [4,5,6], [7,8,9]]
    yd = copy.deepcopy(xs)
    print(f"깊은 복사 원본 > {yd}")
    # (1-1) 얕은복사는 원본컬렉션 자체 CRUD수정시 안 변한다.
    xs.append([10, 11, 12])
    print(f"원본 수정 > {xs}")
    print(f"깊은 복사 > {yd}")
    # (1-2) 얕은복사는 내부요소 조작시, 값이 아니라면 같이 변한다. 요소 복사를 안한다.
    xs[1][0] = 'X' # 원본의 2번째 요소의 값을 변화
    print(f"원본 수정 > {xs}")
    print(f"깊은 복사 > {yd}") # 얕은복사본의 요소도 같이 변화



 
 
if __name__ == '__main__': 
    solution() 
