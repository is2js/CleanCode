def solution(): 
    # 반복문에 올라갈 수 있는 객체 2가지
    # (1) 이터러블 객체 (2) 시퀀스 객체
    # (1) 이터러블 객체: __iter__를 구현한 객체
    #     -> 이터러블 객체의 __iter__는 이터레이터 객체(self)를 반환한다.
    #     (1-2) 이터레이터 객체: __next__를 구현한 객체
    #           -> 반복요소의 index개념 변수를 _private필드로 만들고, 호출시마다 한칸씩 전진하며
    #           _private필드인 index개념변수를 업데이트 후, 기존 값은 반환한다.
    #     (1-3) 제네레이터 객체: __next__에 return 대신 yield를 사용한 객체
    #           -> yield 는 어떤 값을 내보낸 뒤, 해당 함수가 다시 호출될 때까지 yield 그 자리에서 대기한다.
    # (2) 시퀀스 객체 : __len__과 __getitem__ 구현 객체
    # -> 0부터 시작하는 index로 한번에 하나씩 차례대로 요소를 가져올 수 있는 객체

    # 반복문 속에서 작동 과정 for i in A
    # (1) 이터러블 객체: __iter__호출 -> 이터레이터 객체 반환 -> __next__ 루프마다 호출 -> StopIteration을 반환후 멈춤
    # (2) 시퀀스 객체 : __getitem__호출 -> IndexError전까지 인덱스를 증가시키며 해당 인덱스의 요소를 반환
    # (3) 그외 객체: TypeError반환
    pass


    # [이터러블 객체와 시퀀스 객체의 트레이드 오프]
    #
    # 이터러블은 매 루프마다 하나의 값만 반환하며 반복하는 반면,
    # -> iter로 반환된 self객체가 next호출시마다 1개의 요소를 그자리에서 만들어 반환(인덱스개념변수가 이동하면서)
    # 시퀀스는 루프 초기에 반복해야 하는 모든 값을 미리 만들어둔 뒤 반복한다.
    # -> 객체 생성시부터 따로 내수용메서드로 list에 모든 요소를 만들어놓고, -> 반복문에선 자동 index를 받아 -> __getitem__을 호출해서 1개씩 반환
    #
    # 즉, 이터러블의 경우 메모리를 한번에 쓰지 않지만, 시퀀스는 메모리를 한 번에 쓰는 단점이 있다.
    # 하지만, 이터러블은 특정 인덱스에 접근하는데 O(n) 만큼 걸리고, 시퀀스는 O(1) 만 걸리므로 속도면에서 빠르다.
    #
    # 이는 일반적인 컴퓨터 공학에서의 '공간(메모리)- 시간' 의 트레이드 오프적 관계다.
 
 
if __name__ == '__main__': 
    solution() 
