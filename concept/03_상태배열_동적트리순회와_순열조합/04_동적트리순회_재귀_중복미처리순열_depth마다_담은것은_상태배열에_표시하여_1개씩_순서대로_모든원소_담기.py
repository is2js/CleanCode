from typing import List

def permutation(arr: List, r: int) -> None:
    arr = sorted(arr)
    # 1. 0으로 초기화된, arr의 상태관리배열
    used = [0 for _ in range(len(arr))]
    # 2. 결과값을 저장할 list
    # -> 꼬리재귀 == 1개로만 연결된 linkedlist == return에서 다음재귀호출
    #    누적결과값변수를 물고다니며, 초기인자를 직접 준다.
    # BUT
    #    여기서는 linkedlist가 아니라 n번째 -> n-1번째가 여러식 -> 꼬리재귀 x -> 자식들을 순회하며 재귀호출
    #    -> 결과값은 자식들 종착역마다 append해야함.(값배열이라면 얕은복사해서 append)
    #    -> 저장할 결과값 변수 미리 빼놔야한다.
    result = []

    # 3. n개 순열은  n-1개 순열  재귀호출은 i번째커서의 상태가 사용안한상태라고 가정하고,
    #    1) i개의 요소를 반복문으로 돌면서,
    #    2) 현재 커서의 요소가 사용안한 상태일때만(if not used[i]),
    #       + 현재커서를 chosen [] 에 넣어놓고
    #       + 사용상태로 바꿔서
    #       chosen을 누적결과값으로 하는 꼬리재귀를 돌려( 현재커서는 사용중이고, 다른 3개가 반복문이 돌아가면서 확인한다)
    #       그렇다면, 넣고+사용상태를 만들 때마다 depth가 늘어나며, chosen은 채워진다.
    #       누적결과값은 꼬리재귀라면 종착역(마지막연산에서 한번더 온 것)에서 값을 return하지만,
    #       for문으로 동적트리순회 재귀는 종착역에서 print를 하거나, 변수에 따로 저장하는 로직을 가진다.
    #       back해서 돌아오면, 다시 현재커서의 사용상태를 0으로 바꾸고, chosen에서 빼준다.
    #    3) node에서 다음자식들에게 넘어갈 때의 조건이 필요하다. 여기서는 i번째 인자가 사용안된 상태일때, 누적상태값에 포함시킨다.
    #    4) 동적트리순회 재귀의 인자는,
    #       (1) 객체라면 [재귀 주체 객체,]를, 값 n -> n-1, 동적인메모리주소를 공유하는 컬렉션이라면, 인자에 안넣어도 변화가 반영된다. arr, used(?)
    #       (2) n번째 일을 할 때 업데이트되는 변수 (arr가 아닌 arr의 상태관리배열)
    #       (3) depth마다 변했다가 복구되는 휘발성 누적결과값 (결과값x반환x지)  -> 종착역에서 print or 저장
    #    5) i자식으로 갔다가 다음 i+1자식으로 건너가기전에, 3)에 변화준 상태를 복구해야한다.
    #       완전히 새로운 경우로서 넘어가는 것이기 때문.
    #      -> 동적트리순회는 자식들돌고나서 종결처리를 해줘야한다.

    # 3-1. 인자에는 [자식으로 넘어가기전에 변하고 + 복구되는 상태값]들을 넣어줘야한다.
    #      1) 상태관리배열은 무조건 변한다. used -> 현재 초기상태다.
    #      2) chosen이라고, 자식node노드로 깊어질때마다 변하고, 올라왔을때 사라지는 휘발성결과값이다. -> 변한다. -> 초기값으로 내수형 재귀메서드에 넣어준다.
    def generate_permutation(used, chosen):
        # 4. tree의 끝node 종착역 설정 -> chosen도 어짜피 누적휘발성 누적결과값이고, 이것을 기준으로 [꼬리재귀아니여서 연산없는 특이점객체x 마지막연산다음것]
        #  ->마지막연산다음 것으로서 잡을 수 있다.
        if len(chosen) == r:
            # 4-1. 값배열은 얕은복사로 복사해서 저장해야지, 안그러면 누적결과값으로서 계속변한다. 휘발성으로서 back 다하면 비어잇을 것이다.
            result.append(chosen[:])

        # 5. 동적트리순회는, 컴포지트객체 아니면 자신의 일이 거의없다. -> 다음자식으로 가는 것 자체에 상태값을 변화시키고, 휘발성누적결과값을 조정한다.
        for index in range(len(arr)):
            # 5-1. 상태값을 가진 배열을 순회할 땐, [순회전 그 상태값 확인]의 조건이 붙는다.
            #     index = 0
            #     while index < len(arr):
            #         if counter[index] == index:
            #             counter[index] = 0
            #             index += 1
            #             continue
            #if not used[index]: # 0 -> false -> if not시 true -> 0으로 사용안한 상태일때만 [해당 값을 chosen에 포함시켜 node순회를 허용한다]
            # 그렇다면.. 사용중일때는 ealry continue시켜도 된다
            if used[index]:
                continue
            # 6. 자식으로 뻗어나갈 때, 해당 자식을 사용상태로 변화 + 휘발성결과값변수에 추가한다.
            chosen.append(arr[index]) # action
            used[index] = 1 # state
            # 7. 재귀를 통한, 다음노드 진입자체는 [사실상 상태변화후 그 상태로 진입후 대기]이다.
            #    점점 상태값이 사용안된 것들만 필터링해서, depth를 늘려가고, chosen은 늘어나면서 -> 종착역에 도착할 것이다.
            generate_permutation(used, chosen)
            # 8. 재귀가 끝났다는 것은, depth를 다시 복구한 뒤, 다음 자식으로 갈 준비를 한다는 말이다.
            chosen.pop()
            used[index] = 0

    generate_permutation(used, [])

    # 9. 사용하지 않은 1개를 선택한 상태에서, 나머지들을 돌면서 1개씩 선택해나간다.
    return result


if __name__ == '__main__':
    print(permutation([1, 2, 3], 2))
